import React, { useState, useEffect } from 'react';

// -----------------------------------------------------------------------
// API KEYS CONFIGURATION
const PIXABAY_KEY = '35727559-0e840d0e0fcf00ac6876a7099'; 
// -----------------------------------------------------------------------

// Built-in "Safety Net" Dictionary
const translations = {
  "dog": "Perro",
  "cat": "Gato",
  "table": "Mesa",
  "chair": "Silla",
  "apple": "Manzana",
  "book": "Libro",
  "pen": "Bolígrafo",
  "house": "Casa",
  "tree": "Árbol",
  "sun": "Sol",
  "moon": "Luna",
  "water": "Agua",
  "car": "Coche",
  "flower": "Flor",
  "bird": "Pájaro",
  "fish": "Pez",
  "ball": "Pelota",
  "computer": "Ordenador",
  "shirt": "Camisa",
  "shoe": "Zapato",
  "boy": "Niño",
  "girl": "Niña",
  "family": "Familia"
};

export default function FlashcardGenerator() {
  // Default text showing new syntax
  const [wordsInput, setWordsInput] = useState('Dog, Cat\nFootball == Jugar al fútbol\nCinema == Ir al cine\nHouse, Tree, Sun, Moon, Water');
  
  const [cards, setCards] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  // Teaching Mode State: 'full', 'scaffold', 'blank'
  const [labelMode, setLabelMode] = useState('full');

  // Grid Configuration State
  const [gridConfig, setGridConfig] = useState({ size: 'standard', limit: 9, cols: 3 });
  
  // Track specific card loading state
  const [refreshingCard, setRefreshingCard] = useState(null);
  
  // Track which card is being edited (to reveal full text)
  const [focusedCardIndex, setFocusedCardIndex] = useState(null);

  // --- SEARCH MODE STATE ---
  const [searchCardIndex, setSearchCardIndex] = useState(null);
  const [tempSearchTerm, setTempSearchTerm] = useState('');

  // Load PptxGenJS Library dynamically
  useEffect(() => {
    if (!window.PptxGenJS) {
      const script = document.createElement('script');
      script.src = "https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js";
      script.async = true;
      document.body.appendChild(script);
    }
  }, []);

  /**
   * CORE IMAGE FETCHING LOGIC (VECTORS ONLY)
   */
  const fetchVectorImage = async (term, page = 1) => {
    if (!PIXABAY_KEY) return null;

    let imageUrl = null;
    try {
      const response = await fetch(`https://pixabay.com/api/?key=${PIXABAY_KEY}&q=${encodeURIComponent(term)}&image_type=vector&per_page=3&page=${page}`);
      
      if (response.ok) {
        const data = await response.json();
        if (data.hits && data.hits.length > 0) {
          imageUrl = data.hits[0].webformatURL;
        }
      }
    } catch (err) {
      console.error("Pixabay fetch failed", err);
    }
    return imageUrl;
  };

  /**
   * MASKING LOGIC
   */
  const getMaskedLabel = (text, mode) => {
    if (!text) return "";
    
    if (mode === 'blank') {
      return "________________";
    }
    
    if (mode === 'scaffold') {
      return text.split(' ').map(word => {
        if (word.length === 0) return "";
        if (word.length === 1) return word;
        const firstChar = word.charAt(0);
        const rest = "*".repeat(word.length - 1);
        return firstChar + rest;
      }).join(' '); 
    }

    return text;
  };

  const handleGenerate = async () => {
    if (!PIXABAY_KEY) {
      setError('Please ensure the Pixabay API key is set in the code.');
      return;
    }

    setError('');
    setLoading(true);

    const rawItems = wordsInput
      .split(/[,\n]+/)
      .map(w => w.trim())
      .filter(w => w.length > 0)
      .slice(0, gridConfig.limit);

    if (rawItems.length === 0) {
      setError('Please enter at least one word.');
      setLoading(false);
      return;
    }

    const newCards = [];

    for (const item of rawItems) {
      let searchTerm = '';
      let displayLabel = '';

      if (item.includes('==')) {
        const parts = item.split('==');
        searchTerm = parts[0].trim();
        displayLabel = parts[1] ? parts[1].trim() : ''; 
      } else {
        searchTerm = item;
        const lowerWord = searchTerm.toLowerCase();
        if (translations[lowerWord]) {
          displayLabel = translations[lowerWord];
        } else {
          displayLabel = item;
        }
      }

      const imageUrl = await fetchVectorImage(searchTerm, 1);

      newCards.push({ 
        word: displayLabel, 
        searchTerm: searchTerm, 
        image: imageUrl,
        isEmpty: false
      });
    }

    while (newCards.length < gridConfig.limit) {
      newCards.push({ word: '', searchTerm: '', image: null, isEmpty: true });
    }

    setCards(newCards);
    setLoading(false);
  };

  const handleLabelChange = (index, newText) => {
    const updatedCards = [...cards];
    updatedCards[index].word = newText;
    setCards(updatedCards);
  };

  const handleImageUpload = (index, event) => {
    const file = event.target.files[0];
    if (file) {
      const newCards = [...cards];
      newCards[index].image = URL.createObjectURL(file);
      setCards(newCards);
    }
  };

  // --- REFRESH LOGIC (Random Page) ---
  const handleRefreshImage = async (index, searchTerm) => {
    if (!searchTerm) return;
    setRefreshingCard(index);

    const randomPage = Math.floor(Math.random() * 19) + 2;
    const imageUrl = await fetchVectorImage(searchTerm, randomPage);

    const newCards = [...cards];
    if (imageUrl) {
      newCards[index].image = imageUrl;
    } else {
      alert(`No other vector images found for "${searchTerm}"`);
    }
    
    setCards(newCards);
    setRefreshingCard(null);
  };

  // --- MANUAL SEARCH LOGIC ---
  const openSearchMode = (index) => {
    setSearchCardIndex(index);
    setTempSearchTerm('');
  };

  const cancelSearchMode = () => {
    setSearchCardIndex(null);
    setTempSearchTerm('');
  };

  const executeManualSearch = async (index) => {
    if (!tempSearchTerm.trim()) return;
    
    setRefreshingCard(index); 
    const imageUrl = await fetchVectorImage(tempSearchTerm, 1);

    if (imageUrl) {
      const newCards = [...cards];
      newCards[index].image = imageUrl;
      setCards(newCards);
      setSearchCardIndex(null);
    } else {
      alert(`No vector images found for "${tempSearchTerm}"`);
    }
    setRefreshingCard(null);
  };

  // --- PPTX EXPORT LOGIC ---
  const handleDownloadSlides = () => {
    if (!window.PptxGenJS) {
      alert("Presentation generator is still loading. Please wait a moment.");
      return;
    }

    const pptx = new window.PptxGenJS();
    pptx.layout = 'LAYOUT_16x9'; 

    cards.forEach(card => {
      if (!card.isEmpty) {
        let slide = pptx.addSlide();
        slide.background = { color: 'FFFFFF' };

        if (card.image) {
          slide.addImage({
            path: card.image,
            x: '10%', y: '5%', w: '80%', h: '75%',
            sizing: { type: 'contain', align: 'center' }
          });
        }

        slide.addText(card.word, {
          x: 0, y: '82%', w: '100%', h: '15%',
          fontSize: 48, bold: true, align: 'center', color: '000000', fontFace: 'Arial'
        });
      }
    });

    const validCards = cards.filter(c => !c.isEmpty);
    if (validCards.length > 0) {
      let summarySlide = pptx.addSlide();
      summarySlide.background = { color: 'FFFFFF' };

      summarySlide.addText("Resumen", {
        x: 0, y: 0.1, w: '100%', h: 0.5,
        fontSize: 24, bold: true, align: 'center', color: '333333'
      });

      const startX = 0.5;
      const startY = 0.8;
      const colWidth = 9.0 / gridConfig.cols; 
      const rowHeight = 4.5 / Math.ceil(gridConfig.limit / gridConfig.cols);

      validCards.slice(0, gridConfig.limit).forEach((card, index) => {
        const col = index % gridConfig.cols;
        const row = Math.floor(index / gridConfig.cols);
        
        const xPos = startX + (col * colWidth);
        const yPos = startY + (row * rowHeight);

        if (card.image) {
          summarySlide.addImage({
            path: card.image,
            x: xPos + (colWidth * 0.1), 
            y: yPos,
            w: colWidth * 0.8,
            h: rowHeight * 0.7,
            sizing: { type: 'contain', align: 'center' }
          });
        }

        const displayText = getMaskedLabel(card.word, labelMode);

        summarySlide.addText(displayText, {
          x: xPos, 
          y: yPos + (rowHeight * 0.75), 
          w: colWidth, 
          h: 0.3,
          fontSize: gridConfig.cols === 4 ? 10 : 12, 
          bold: true, 
          align: 'center', 
          color: '000000', 
          fontFace: 'Arial'
        });
      });
    }

    pptx.writeFile({ fileName: 'Flashcards.pptx' });
  };

  const handlePrint = () => {
    window.print();
  };

  return (
    <div className="min-h-screen bg-slate-50 text-slate-800 font-sans pb-20">
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap');
        body { font-family: 'Nunito', sans-serif; }
      `}</style>

      {/* ----------------- HEADER ----------------- */}
      <header className="bg-teal-600 text-white pt-8 pb-12 rounded-b-[2.5rem] shadow-lg mb-8 no-print">
        <div className="max-w-5xl mx-auto px-6 text-center">
          <h1 className="text-4xl font-extrabold tracking-tight mb-2">VibeWord</h1>
          <p className="text-teal-100 font-medium text-lg">Visual Vocabulary Generator</p>
        </div>
      </header>

      {/* ----------------- CONTROL CARD ----------------- */}
      <div className="max-w-5xl mx-auto px-4 mb-12 no-print">
        <div className="bg-white rounded-2xl shadow-xl border border-slate-100 p-6 md:p-8">
          
          {/* Grid Size Buttons */}
          <div className="flex flex-wrap items-center gap-4 mb-6">
            <span className="text-sm font-bold text-slate-500 uppercase tracking-wider">Layout</span>
            <div className="flex bg-gray-50 p-1 rounded-full border border-gray-100">
              {[
                { id: 'small', label: 'Small (3x2)', limit: 6, cols: 3 },
                { id: 'standard', label: 'Standard (3x3)', limit: 9, cols: 3 },
                { id: 'large', label: 'Large (4x3)', limit: 12, cols: 4 }
              ].map((opt) => (
                <button
                  key={opt.id}
                  onClick={() => setGridConfig({ size: opt.id, limit: opt.limit, cols: opt.cols })}
                  className={`px-4 py-2 rounded-full text-sm font-bold transition-all ${
                    gridConfig.size === opt.id 
                      ? 'bg-white text-teal-600 shadow-sm ring-1 ring-black/5' 
                      : 'text-slate-400 hover:text-slate-600'
                  }`}
                >
                  {opt.label}
                </button>
              ))}
            </div>
          </div>

          {/* Input Area */}
          <div className="mb-6 relative">
             <label className="block text-sm font-bold text-slate-700 mb-2">Vocabulary List</label>
             <textarea
                value={wordsInput}
                onChange={(e) => setWordsInput(e.target.value)}
                placeholder={`Paste your list here...\n\nExample:\nFootball == Jugar al fútbol\nDog, Cat`}
                className="w-full p-5 bg-gray-50 border border-gray-200 rounded-2xl h-40 focus:ring-4 focus:ring-teal-500/20 focus:border-teal-500 outline-none text-lg text-slate-700 leading-relaxed font-medium transition-all"
              />
              <p className="absolute bottom-4 right-4 text-xs text-slate-400 pointer-events-none">
                Accepts "Word" or "Word == Phrase"
              </p>
          </div>

          {error && <div className="bg-red-50 text-red-600 px-4 py-2 rounded-lg font-medium text-sm mb-4">{error}</div>}

          {/* Action Bar */}
          <div className="flex flex-col md:flex-row gap-4 pt-4 border-t border-slate-100 items-center">
            <div className="relative w-full md:w-auto">
              <select 
                value={labelMode}
                onChange={(e) => setLabelMode(e.target.value)}
                className="w-full md:w-auto pl-4 pr-10 py-3 rounded-full bg-gray-50 border border-gray-200 text-slate-700 font-bold hover:bg-gray-100 focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition-all appearance-none cursor-pointer"
              >
                <option value="full">Mode: Full Labels</option>
                <option value="scaffold">Mode: Scaffolded</option>
                <option value="blank">Mode: Blank Quiz</option>
              </select>
              <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-slate-500">
                <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
              </div>
            </div>
            
            <button
              onClick={handleGenerate}
              disabled={loading}
              className={`w-full md:w-auto px-8 py-3 rounded-full text-white font-extrabold text-lg transition-all shadow-md active:scale-95 flex items-center justify-center gap-2 ${
                loading ? 'bg-teal-300 cursor-wait' : 'bg-teal-500 hover:bg-teal-600 hover:shadow-lg'
              }`}
            >
              {loading ? <span>Fetching...</span> : (
                <>
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clipRule="evenodd" /></svg>
                  Generate Grid
                </>
              )}
            </button>

            {cards.length > 0 && (
              <div className="flex gap-3 w-full md:w-auto md:ml-auto justify-end">
                <button
                  onClick={handlePrint}
                  className="px-6 py-3 rounded-full bg-amber-400 hover:bg-amber-500 text-white font-bold text-base transition-all shadow-md active:scale-95 flex items-center gap-2"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
                  </svg>
                  Print
                </button>

                <button
                  onClick={handleDownloadSlides}
                  className="px-6 py-3 rounded-full bg-amber-400 hover:bg-amber-500 text-white font-bold text-base transition-all shadow-md active:scale-95 flex items-center gap-2"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                  </svg>
                  Slides
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* ----------------- THE GRID (A4 PREVIEW) ----------------- */}
      {cards.length > 0 && (
        <div className="flex justify-center mb-10 print:mb-0 print:block">
          <div 
            className="print-container bg-white shadow-2xl mx-auto relative overflow-hidden"
            style={{
              width: '210mm', height: '297mm', padding: '10mm', boxSizing: 'border-box'
            }}
          >
            <div className={`grid gap-6 w-full h-full ${
              gridConfig.size === 'small' ? 'grid-cols-3 grid-rows-2' : 
              gridConfig.cols === 3 ? 'grid-cols-3 grid-rows-3' : 
              'grid-cols-4 grid-rows-3'
            }`}>
              {cards.map((card, index) => (
                <div 
                  key={index} 
                  className={`group relative bg-white rounded-xl flex flex-col items-center justify-between p-3 border border-slate-100 border-b-4 border-b-slate-200 shadow-sm transition-all duration-300 hover:-translate-y-1 hover:shadow-lg hover:border-b-teal-400 ${card.isEmpty ? 'opacity-0' : ''}`}
                >
                  {/* --- ACTION OVERLAY --- */}
                  {!card.isEmpty && (
                    <div className="no-print absolute top-3 left-3 right-3 z-20">
                      
                      {/* SEARCH INPUT OVERLAY */}
                      {searchCardIndex === index ? (
                        <div className="flex gap-2 p-1.5 bg-white/95 backdrop-blur-sm rounded-full shadow-xl border border-teal-200 animate-in fade-in zoom-in-95 duration-200">
                          <input
                            autoFocus
                            type="text"
                            placeholder="Search..."
                            value={tempSearchTerm}
                            onChange={(e) => setTempSearchTerm(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && executeManualSearch(index)}
                            className="w-full bg-transparent text-sm px-2 text-slate-700 outline-none placeholder:text-slate-400"
                          />
                          <button 
                            onClick={() => executeManualSearch(index)}
                            className="bg-teal-500 hover:bg-teal-600 text-white rounded-full p-1.5 transition-colors"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                            </svg>
                          </button>
                          <button 
                            onClick={cancelSearchMode}
                            className="bg-slate-200 hover:bg-slate-300 text-slate-600 rounded-full p-1.5 transition-colors"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                              <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                            </svg>
                          </button>
                        </div>
                      ) : (
                        // NORMAL BUTTONS
                        <div className="flex justify-between w-full opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                          {/* Left Group */}
                          <div className="flex gap-2">
                            {/* Refresh Button */}
                            <button 
                              onClick={() => handleRefreshImage(index, card.searchTerm)}
                              disabled={refreshingCard === index}
                              className={`shadow-md bg-white border border-slate-100 text-slate-400 hover:text-teal-600 p-2 rounded-full ${refreshingCard === index ? 'animate-spin' : ''}`}
                              title="Cycle Image"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                              </svg>
                            </button>
                            {/* Search Button */}
                            <button 
                              onClick={() => openSearchMode(index)}
                              className="shadow-md bg-white border border-slate-100 text-slate-400 hover:text-teal-600 p-2 rounded-full"
                              title="Search manually"
                            >
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                              </svg>
                            </button>
                          </div>

                          {/* Right Group: Upload */}
                          <label 
                            className="cursor-pointer bg-white text-slate-400 hover:text-teal-600 p-2 rounded-full shadow-md border border-slate-100 flex items-center justify-center transition-colors"
                            title="Upload your own image"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                            </svg>
                            <input 
                              type="file" 
                              className="hidden" 
                              accept="image/*"
                              onChange={(e) => handleImageUpload(index, e)}
                            />
                          </label>
                        </div>
                      )}
                    </div>
                  )}

                  {/* Image Area */}
                  <div className="flex-grow w-full flex items-center justify-center overflow-hidden mb-3 rounded-lg bg-white">
                    {card.image ? (
                      <img 
                        src={card.image} 
                        alt={card.searchTerm} 
                        className="w-full h-full object-contain transition-transform duration-500 group-hover:scale-105"
                        style={{ opacity: refreshingCard === index ? 0.5 : 1 }}
                      />
                    ) : (
                      <div className="w-full h-full bg-slate-50 rounded-lg flex items-center justify-center text-slate-300 text-xs font-bold text-center p-4">
                        {card.isEmpty ? '' : 'No Image Found'}
                      </div>
                    )}
                  </div>

                  {/* Text Area (EDITABLE TEXTAREA with Wrapping) */}
                  <div className="w-full flex items-center justify-center pt-3 pb-1 border-t border-slate-50 min-h-[4rem]">
                    <textarea
                      value={focusedCardIndex === index ? card.word : getMaskedLabel(card.word, labelMode)}
                      onChange={(e) => handleLabelChange(index, e.target.value)}
                      onFocus={() => setFocusedCardIndex(index)}
                      onBlur={() => setFocusedCardIndex(null)}
                      rows={2}
                      className="text-xl md:text-2xl font-extrabold text-indigo-700 text-center w-full bg-transparent border-none outline-none focus:bg-indigo-50 focus:ring-2 focus:ring-indigo-200 rounded-lg px-2 py-1 transition-all decoration-dotted underline decoration-2 decoration-indigo-200 hover:decoration-indigo-400 resize-none overflow-hidden leading-tight whitespace-normal break-words"
                      placeholder="Type label..."
                    />
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* ----------------- PRINT CSS STYLES ----------------- */}
      <style>{`
        @media print {
          @page { size: A4 portrait; margin: 0; }
          body { background: white; margin: 0; padding: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
          .no-print { display: none !important; }
          .print-container { width: 210mm !important; height: 297mm !important; margin: 0 !important; padding: 10mm !important; box-shadow: none !important; border: none !important; overflow: hidden !important; }
          .print\\:hidden { display: none !important; }
          /* Remove input/textarea styling on print */
          textarea { background: transparent !important; border: none !important; text-decoration: none !important; resize: none !important; }
          /* Enforce card borders on print */
          .border-b-4 { border-bottom-width: 4px !important; }
        }
      `}</style>
    </div>
  );
}